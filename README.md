# RUN
## docker-compose up --build

# TEST
## Открыть URL http://localhost:8000/docs 

## Вы увидите swagger, поменяйте значения
{
  "user_name": "Ivan",
  "user_surname": "Ivanov",
  "user_job": "Data Scientist"
}

## Запустите контейнер Postgres
docker exec -it postgres-container psql -U myuser -d mydatabase

## Проверь, что получилось!
SELECT * FROM users;


# LAB_1
# BAD PRACTICE OF USING CONTAINERIZATION

Лучше использовать монолит в следующих случаях:

1) Когда быстро нужно получить MVP, работа над стартапами
2) Должно быть легкое тестирование
3) В некоторых областях в принципе лучше использовать именно монолит (сфера телефонии, как пример из лекции)
4) Нужно исходить из принципов работы команды, а не только от архитектуры приложения (команда сплоченная, видят общую архитектуру, для них нет необходимости изоляции модулей) 
5) Более высокая производительность по сравнению с микросервисами

# DESCRIPTION OF GOOD DOCKERFILE

- IMAGE python с тегом 3.9 (используем питоновский образ)
- создаем рабочую директорию внутри контейнера (это как cd для терминала ОС, влияет на то, как выполнятся нижеследующие команды в докерфайле)
- копируем то, что у нас лежит в проекте в текущую директорию /app контейнера (потому что ".")
- выполняем команду ВНУТРИ контейнера (не сохраняем кэш, устанавливаем перечисленные зависимости)
- копируем все, что есть в локальных файлах в наш контейнер
- команда, которая выполняется при запуске контейнера (не путать с RUN, который нужен для выполнения команд в ПРОЦЕССЕ сборки) не забываем указывать хосты и порты, где будет запущен контейнер ;)

# DESCRIPTION OF BAD DOCKERFILE

- В плохом докерфайле можно заметить, что мы используем образ Python без явного указания конкретной версии образа
- Все наши команды выполняются в корне, копируем ВСЕ файлы сразу (теряется возможность кеширования отдельных файлов, возможно нужно игнорировать некоторые файлы при помощи dockerignore)
- Мы не используем requirements.txt, что КРАЙНЕ неудобно, если зависимостей довольно много
- Не указываем конкретный порт, на котором будет работать контейнер (может привести к проблемам)

# LAB_2

## Контейнеры
### - init: 
Используется базовый образ python:3.9. Подключен к сети my_network. Выполняет команду в оболочке, которая симулирует процесс инициализации с помощью команд echo и задержки через sleep. Для перезапуска установлено значение no, что означает, что контейнер не будет перезапущен после остановки.
### - postgres:
Используется официальный образ postgres:14. Открыт порт 5432 для доступа к базе данных. В перемнных окружения конфигурируются учетные данные для postgres (пользователь, пароль и база данных), которые находятся в файле .env. Подключен к сети my_network. Для проверки работоспособности используется команда pg_isready, чтобы убедиться, что база данных готова к использованию. Данные контейнера сохраняются в томе postgres_data. Правила перезапуска не указаны явно (по умолчанию - always).
### - fastapi: 
Для сборки используется образ из Dockerfile в директории ./backend. Открыт порт 8000 для FastAPI. В переменных окружения конфигурируется URL для подключения к базе данных postgres. Сервис fastapi запускается только после того, как сервис postgres будет готов (здоров). Подключен к сети my_network. Приложение FastAPI запускается с помощью uvicorn на порту 8000. Во время проверки работоспособности смотрим, что сервис FastAPI доступен через HTTP-запрос на эндпоинт /health. Контейнер перезапускается явно
### - grafana: 
Используется последний официальный образ grafana. Порт 3001 на хосте пробрасывается на порт 3000 внутри контейнера. Подключен к сети my_network. В переменных окружения конфигурируются учетные данные для Grafana. Данные сохраняются в томе grafana-data. Сервис grafana запускается только после того, как сервис postgres будет готов (здоров). Во время проверки работоспособности смотрим, что сервис Grafana доступен через HTTP-запрос на http://localhost:3000. Правила перезапуска не указаны явно (по умолчанию - always).
## Сети:
### - my_network: 
Определена пользовательская сеть типа bridge для связи между сервисами.
## Тома:
### - postgres_data: 
Сохраняет данные для контейнера postgres.
### - grafana-data: 
Сохраняет данные для контейнера grafana.

# HOW TO LIMIT RESOURCES?

Да, можно ограничивать ресурсы для сервисов. Можно написать так:

![image](https://github.com/user-attachments/assets/57de3001-4922-4cb9-8f72-7733a374ac8c)

          
limits - максимум, сколько получит сервис. В данном случае 50% от одного ядра процессора и 512 мб оперативной памяти\
reservations - минимум, который предоставлен сервису

# DOCKER-COMPOSE UP FOR ONLY CERTAIN CONTAINERS

При запуске композа можно указать, какой именно сервис запускать. К примеру, запустим на фоне сервис fastapi:

docker-compose up fastapi

Почитать: https://stackoverflow.com/questions/30233105/docker-compose-up-for-only-certain-containers
