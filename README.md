# RUN
## sudo docker-compose -f docker-compose.yml up --build

# TEST
## Открыть URL http://localhost:8000/docs 

## Вы увидите swagger, поменяйте значения
{
  "user_name": "Ivan",
  "user_surname": "Ivanov",
  "user_job": "Data Scientist"
}

## Запустите контейнер Postgres
docker exec -it postgres-container psql -U myuser -d mydatabase

## Проверь, что получилось!
SELECT * FROM users;


# BAD PRACTICE FOR DOCKERFILES

1) В плохом докерфайле можно заметить, что мы используем образ Python без явного указания конкретной версии образа
2) Все наши команды выполняются в корне, копируем ВСЕ файлы сразу (теряется возможность кеширования отдельных файлов, возможно нужно игнорировать некоторые файлы при помощи dockerignore)
3) Мы не используем requirements.txt, что КРАЙНЕ неудобно, если зависимостей довольно много
4) Не указываем конкретный порт, на котором будет работать контейнер (может привести к проблемам)

# BAD PRACTICE OF USING CONTAINERIZATION

Лучше использовать монолит в следующих случаях:

1) Когда быстро нужно получить MVP, работа над стартапами
2) Должно быть легкое тестирование
3) В некоторых областях в принципе лучше использовать именно монолит (сфера телефонии, как пример из лекции)
4) Нужно исходить из принципов работы команды, а не только от архитектуры приложения (команда сплоченная, видят общую архитектуру, для них нет необходимости изоляции модулей) 
5) Более высокая производительность по сравнению с микросервисами
